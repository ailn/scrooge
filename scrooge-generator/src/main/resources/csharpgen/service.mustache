{{>autogen}}
{{>package}}
{
    {{#i_4}}{{>type_imports}}{{/i_4}}
    {{#i_4}}{{>thrift_imports}}{{/i_4}}
    {{#i_4}}{{>service_imports}}{{/i_4}}

    public class {{name}}
    {
        public interface Iface{{#extends_iface}} : {{name}}.Iface{{/extends_iface}}
        {
          {{#functions}}
          {{{return_type.type_name}}} {{name}}({{{argument_list_with_types}}});
          {{/functions}}
        }

        public interface ServiceIface{{#extends_iface}} : {{name}}.ServiceIface{{/extends_iface}}
        {
          {{#functions}}
          Task<{{{return_type.type_name_in_container}}}> {{name}}({{{argument_list_with_types}}});
          {{/functions}}
        }

        public class Client{{#extends_iface}} : {{name}}.Client{{/extends_iface}}{{^extends_iface}} : TServiceClient, Iface{{/extends_iface}}
        {
            public class Factory : TServiceClientFactory<Client>
            {
                public Factory() {}
                public Client GetClient(TProtocol prot)
                {
                    return new Client(prot);
                }
                public Client GetClient(TProtocol iprot, TProtocol oprot)
                {
                    return new Client(iprot, oprot);
                }
            }
            {{^extends_iface}}
            public Client(TProtocol prot) : base(prot) { }

            public Client(TProtocol iprot, TProtocol oprot) : base(iprot, oprot) { }
            {{/extends_iface}}
            {{#functions}}
            public {{{return_type.type_name}}} {{name}}({{{argument_list_with_types}}})
            {
                send_{{name}}({{{argument_list}}});
                {{^is_oneway}}
                {{^return_type.is_void}}return {{/return_type.is_void}}recv_{{name}}();
                {{/is_oneway}}
            }

            public void send_{{name}}({{{argument_list_with_types}}})
            {
                this.OutputProtocol.WriteMessageBegin(new TMessage("{{name}}", TMessageType.Call, ++this.SeqId));
                {{name}}_args __args__ = new {{name}}_args();
                {{#fields}}
                __args__.Set{{#cap}}{{name}}{{/cap}}({{name}});
                {{/fields}}
                __args__.Write(this.OutputProtocol);
                this.OutputProtocol.WriteMessageEnd();
                this.OutputProtocol.Transport.Flush();
            }
            {{^is_oneway}}

            public {{{return_type.type_name}}} recv_{{name}}()
            {
                TMessage msg = this.InputProtocol.ReadMessageBegin();
                if (msg.Type == TMessageType.Exception)
                {
                    TApplicationException x = TApplicationException.Read(this.InputProtocol);
                    this.InputProtocol.ReadMessageEnd();
                    throw x;
                }

                if (msg.SeqID != this.SeqId)
                {
                    throw new TApplicationException(TApplicationException.ExceptionType.BadSequenceID, "{{name}} failed: out of sequence response");
                }

                {{name}}_result result = new {{name}}_result();
                result.Read(this.InputProtocol);
                this.InputProtocol.ReadMessageEnd();

                {{^return_type.is_void}}
                if (result.IsSetSuccess())
                {
                    return result.success;
                }
                {{/return_type.is_void}}

                {{#exceptions}}
                if (result.{{name}} != null)
                {
                    throw result.{{name}};
                }
                {{/exceptions}}
                {{#return_type.is_void}}
                return;
                {{/return_type.is_void}}
                {{^return_type.is_void}}
                throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "{{name}} failed: unknown result");
                {{/return_type.is_void}}
            }
            {{/is_oneway}}
            {{/functions}}
        }

        public class ServiceToClient{{#extends_iface}} : {{name}}.ServiceToClient, {{/extends_iface}}{{^extends_iface}} : {{/extends_iface}}ServiceIface
        {
            readonly Finagle.Core.Service<ThriftClientRequest, byte[]> service;
            readonly TProtocolFactory protocolFactory;
            {{^is_oneway}}
            /*private final scala.PartialFunction<com.twitter.finagle.service.ReqRep,com.twitter.finagle.service.ResponseClass> responseClassifier;*/

            public ServiceToClient(Finagle.Core.Service<ThriftClientRequest, byte[]> service, TProtocolFactory protocolFactory/*, scala.PartialFunction<com.twitter.finagle.service.ReqRep,com.twitter.finagle.service.ResponseClass> responseClassifier*/){{#extends_iface}} : base(service, protocolFactory/*, responseClassifier*/);{{/extends_iface}}
            {
                this.service = service;
                this.protocolFactory = protocolFactory;
                /*this.responseClassifier = responseClassifier;*/
            }
            {{/is_oneway}}

            /*
            public ServiceToClient(Finagle.Core.Service<ThriftClientRequest, byte[]> service, TProtocolFactory protocolFactory)
            {
                {{#extends_iface}}super(service, protocolFactory, Finagle.Core.Services.ResponseClassifier.Default());{{/extends_iface}}
                this.service = service;
                this.protocolFactory = protocolFactory;
                {{^is_oneway}}this.responseClassifier = com.twitter.finagle.service.ResponseClassifier.Default();{{/is_oneway}}
            }
            */

            {{#functions}}
            public Task<{{{return_type.type_name_in_container}}}> {{name}}({{{argument_list_with_types}}})
            {
                try {
                    // TODO: size
                    TMemoryBuffer __memoryTransport__ = new TMemoryBuffer();
                    TProtocol __prot__ = this.protocolFactory.GetProtocol(__memoryTransport__);
                    __prot__.WriteMessageBegin(new TMessage("{{name}}", TMessageType.Call, 0));
                    {{name}}_args __args__ = new {{name}}_args();
                    {{#fields}}
                    __args__.Set{{#cap}}{{name}}{{/cap}}({{name}});
                    {{/fields}}
                    __args__.Write(__prot__);
                    __prot__.WriteMessageEnd();


                    byte[] __buffer__ = __memoryTransport__.GetBuffer();
                    ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, {{#is_oneway}}true{{/is_oneway}}{{^is_oneway}}false{{/is_oneway}});

                    return this.service.Invoke(__request__).FlatMap<byte[], {{{return_type.type_name_in_container}}}>(__buffer__1 =>
                    {
                        TMemoryInputTransport __memoryTransport__1 = new TMemoryInputTransport(__buffer__1);
                        TProtocol __prot__1 = this.protocolFactory.GetProtocol(__memoryTransport__1);
                        try
                        {
                            {{#is_oneway_or_void}}
                            {{^is_oneway}}
                            (new Client(__prot__1)).recv_{{name}}();
                            {{/is_oneway}}
                            return Task.FromResult(null);
                            {{/is_oneway_or_void}}
                            {{^is_oneway_or_void}}
                            return Task.FromResult((new Client(__prot__1)).recv_{{name}}());
                            {{/is_oneway_or_void}}
                        }
                        catch (Exception e)
                        {
                            return TaskEx.FromException<{{{return_type.type_name_in_container}}}>(e);
                        }

                    });
                }
                catch (TException e)
                {
                    return TaskEx.FromException<{{{return_type.type_name_in_container}}}>(e);
                }
            }
            {{/functions}}
        }

        public class Service {{#extends_iface}}: {{name}}.Service{{/extends_iface}}{{^extends_iface}}: Finagle.Core.Service<byte[], byte[]>{{/extends_iface}}
        {
            readonly ServiceIface iface;
            readonly TProtocolFactory protocolFactory;

            {{^extends_iface}}
            protected IDictionary<string, Func<TProtocol, int, Task<byte[]>>> functionMap = new Dictionary<string, Func<TProtocol, int, Task<byte[]>>>();
            {{/extends_iface}}

            public Service(ServiceIface iface, TProtocolFactory protocolFactory){{#extends_iface}} : base(iface, protocolFactory){{/extends_iface}}
            {
                this.iface = iface;
                this.protocolFactory = protocolFactory;
                {{#functions}}
                this.functionMap.Add("{{name}}", (iprot, seqid) =>
                {
                    var args = new {{name}}_args();
                    try
                    {
                        args.Read(iprot);
                    }
                    catch (TProtocolException e)
                    {
                        try
                        {
                            iprot.ReadMessageEnd();
                            TApplicationException x = new TApplicationException(TApplicationException.ExceptionType.ProtocolError, e.Message);
                            TMemoryBuffer memoryBuffer = new TMemoryBuffer();
                            TProtocol oprot = this.protocolFactory.GetProtocol(memoryBuffer);

                            oprot.WriteMessageBegin(new TMessage("{{name}}", TMessageType.Exception, seqid));
                            x.Write(oprot);
                            oprot.WriteMessageEnd();
                            oprot.Transport.Flush();
                            byte[] buffer = memoryBuffer.GetBuffer();
                            return Task.FromResult(buffer);
                        }
                        catch (Exception e1)
                        {
                            return TaskEx.FromException<byte[]>(e1);
                        }
                    }
                    catch (Exception e)
                    {
                        return TaskEx.FromException<byte[]>(e);
                    }

                    try
                    {
                        iprot.ReadMessageEnd();
                    }
                    catch (Exception e)
                    {
                        return TaskEx.FromException<byte[]>(e);
                    }

                    Task<{{{return_type.type_name_in_container}}}> future;
                    try
                    {
                        future = iface.{{name}}({{{argument_list_with_args}}});
                    }
                    catch (Exception e)
                    {
                        future = TaskEx.FromException<{{{return_type.type_name_in_container}}}>(e);
                    }

                    {{#is_oneway}}
                    return future.Map(value => byte[0]);
                    {{/is_oneway}}
                    {{^is_oneway}}
                    try
                    {
                        return future.FlatMap(value =>
                        {
                            {{name}}_result result = new {{name}}_result();
                            {{^is_oneway}}{{^return_type.is_void}}
                            result.success = value;
                            result.SetSuccessIsSet(true);
                            {{/return_type.is_void}}{{/is_oneway}}

                            try
                            {
                                TMemoryBuffer memoryBuffer = new TMemoryBuffer();
                                TProtocol oprot = protocolFactory.GetProtocol(memoryBuffer);

                                oprot.WriteMessageBegin(new TMessage("{{name}}", TMessageType.Reply, seqid));
                                result.Write(oprot);
                                oprot.WriteMessageEnd();

                                return Task.FromResult(memoryBuffer.GetBuffer());
                            }
                            catch (Exception e)
                            {
                                return TaskEx.FromException<byte[]>(e);
                            }
                        }).Rescue(t =>
                        {
                            {{^is_oneway}}{{#has_exceptions}}
                            try
                            {
                                {{name}}_result result = new {{name}}_result();
                                {{#exceptions}}
                                {{^first}}else {{/first}}if (t is {{{field_type.type_name}}}) {
                                    result.{{name}} = ({{{field_type.type_name}}})t;
                                }
                                {{/exceptions}}
                                else
                                {
                                    return TaskEx.FromException<byte[]>(t);
                                }
                                TMemoryBuffer memoryBuffer = new TMemoryBuffer();
                                TProtocol oprot = protocolFactory.GetProtocol(memoryBuffer);
                                oprot.WriteMessageBegin(new TMessage("{{name}}", TMessageType.Reply, seqid));
                                result.Write(oprot);
                                oprot.WriteMessageEnd();
                                oprot.Transport.Flush();
                                return Task.FromResult(memoryBuffer.GetBuffer());
                            }
                            catch (Exception e)
                            {
                                return TaskEx.FromException<byte[]>(e);
                            }
                            {{/has_exceptions}}
                            {{^has_exceptions}}
                            return TaskEx.FromException<byte[]>(t);
                            {{/has_exceptions}}
                            {{/is_oneway}}
                            {{#is_oneway}}
                            return TaskEx.FromException<byte[]>(t);
                            {{/is_oneway}}
                        });
                    }
                    catch (Exception e)
                    {
                        return TaskEx.FromException<byte[]>(e);
                    }
                    {{/is_oneway}}
                });
                {{/functions}}
            }

            public override Task<byte[]> Invoke(byte[] request)
            {
                TTransport inputTransport = new TMemoryInputTransport(request);
                TProtocol iprot = this.protocolFactory.GetProtocol(inputTransport);

                TMessage msg;
                try
                {
                    msg = iprot.ReadMessageBegin();
                }
                catch (Exception e)
                {
                    return TaskEx.FromException<byte[]>(e);
                }

                Func<TProtocol, int, Task<byte[]>> fn;
                bool success = this.functionMap.TryGetValue(msg.Name, out fn);
                if (fn == null)
                {
                    try
                    {
                        TProtocolUtil.Skip(iprot, TType.Struct);
                        iprot.ReadMessageEnd();
                        TApplicationException x = new TApplicationException(TApplicationException.ExceptionType.UnknownMethod, "Invalid method name: '"+msg.Name+"'");
                        TMemoryBuffer memoryBuffer = new TMemoryBuffer();
                        TProtocol oprot = this.protocolFactory.GetProtocol(memoryBuffer);
                        oprot.WriteMessageBegin(new TMessage(msg.Name, TMessageType.Exception, msg.SeqID));
                        x.Write(oprot);
                        oprot.WriteMessageEnd();
                        oprot.Transport.Flush();
                        return Task.FromResult(memoryBuffer.GetBuffer());
                    }
                    catch (Exception e)
                    {
                        return TaskEx.FromException<byte[]>(e);
                    }
                }

                return fn.Invoke(iprot, msg.SeqID);
            }
        }

        {{#functions}}
        {{{arg_struct}}}

        {{^is_oneway}}
        {{{result_struct}}}

        {{/is_oneway}}

        {{/functions}}
    }
}
